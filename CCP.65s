  ;OUP/M CCP WRITTEN BY LIO,QI-WEN         
  ;ON AUG. 1982           
 *=$D000              
 JMP MAIN             
 ;6502 CP/M CCP            
 ;*******************************************              
STACKB=$FF              
IBUBCC=$EE80      ;MAX CHAR ADDRESS      
IBUBC=$EE81       ;BUFF COUNTER      
IBUFB=$EE82       ;FIRST CHAR IN BUFF    
IBUFBA=$EF02              
IBUFBB=$EF04              
IBUFC .WORD IBUBC            
IBUFF .WORD IBUFB            
IBUFPA .WORD IBUFB     ;PTR,INIT IBUFB      
IBUFPB .WORD IBUFBB            
FCBB=$EE01              
FCBBB=FCBB+1              
FCBBC=FCBB+$10              
FCBBD=FCBB+$20              
RETVAL=FCBB+$23              
FCBP .WORD FCBB            
FCBPB .WORD FCBBB             
FCBPC .WORD FCBBC             
FCBBP .WORD FCBBD             
DSKNUM=FCBB+$42    ;POINTES THE NUMBER OF      
WRKPLA=FCBB+$43    ;WORK ELEMENT        
WRKPLB=FCBB+$44             
WRKPLC=FCBB+$45             
WRKPLD=FCBB+$46             
WRKPPB .WORD WRKPLB             
RBC=$0067             
RHL=$0069             
RDE=$006D     ;REPLACE Z80 DE,HL,BC      
RWK=$006B             
RWQ=$0060             
RNW=$0062             
DMAD=$E965             
SUBTBL  .WORD SUBPGO            
STRTD=$0200             
SUBPGO .WORD $2710    ;10,000        
  .WORD $03E8     ;1,000       
  .WORD $0064     ;100       
  .WORD $000A     ;10       
MSGAD1 .WORD MSGVER             
CMDTAB .BYTE "DIR ERA TYPESAVEREN USER"          
               
               
TABADD .WORD CMDTAB             
ADRTAB .WORD PDIR,PERA,PTYPE,PSAVE,PREN             
  .WORD PUSER,PTRANS            
TBLAD2 .WORD ADRTAB             
RDERRA .WORD RDERR             
NOFERA .WORD NOFERR             
MSGAD3 .WORD MSGADI             
BDOS=$D93F             
MSGAD5 .WORD MSGAD4             
MSGAD7 .WORD MSGAD6             
MSGDD9 .WORD MSGDD8             
MSGBA2 .WORD MSGBA1             
;***********************************************               
;SUBROUTINE               
;***********************************************               
CHROUT STA RDE      ;OUTPUT CHAR TO E    
  LDX #$02            
  JMP BDOS     ;PRINT A CHARACTER     
CHROB STA WRKPLC     ;FOR SAVING RBC      
  LDA RBC            
  STA RWQ            
  LDA RBC+1            
  STA RWQ+1            
  LDA WRKPLC            
  JSR CHROUT     ;TO PRINT A CHAR    
  LDA RWQ      ;FOR RESTORE RBC    
  STA RBC            
  LDA RWQ+1            
  STA RBC+1            
  RTS             
CRLF LDA #$0D     ;'CR' TO A      
  JSR CHROB     ;OUTPUT CR'      
  LDA #$0A     ;'LF' TO A     
  JMP CHROB     ;OUTPUT LF'      
SPACE LDA #$20     ;' ' TO A     
  JMP CHROB            
;PRINT STRING UNTIL NUL',MESSAGE POINTER IN RDE         
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
STRIOA JSR CRLF     ;OUTPUT CR' LF'      
  LDA RBC      ;GET MESSAGE POINTER    
  STA RHL            
  LDA RBC+1            
  STA RHL+1     ;NOW RHL POINTES MESSAGE    
;PRINT STRING ,MESSAGE IN RHL           
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
STRIOB LDY #$00     ;CLEAR Y       
  LDA (RHL),Y     ;GET A CHAR     
  BNE LOOP1     ;CHAR='NUL'?       
  RTS       ;YES,END PRINT AND RETURN   
LOOP1 INY       ;NO,       
  STY RWQ            
  JSR CHROUT     ;OUTPUT A CHAR     
  LDY RWQ            
  JMP STRIOB+2    ;CONTINUE        
RSTDSK LDX #$0A     ;RESET DISK OPERATION      
               
               
               
               
               
               
  JMP BDOS            
SELDSK LDX #$13     ;SELECT DISK OPERATION      
  JMP BDOS            
;THE FOLLOWING 8 ROUTINES CALL BDOS THEN         
;RETURN VALUE TO RETVAL ,A+1RETURN           
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
CDOSRT LDA RDE             
  LDY RDE+1            
CDOSR1 JSR BDOS             
  STA RETVAL     ;RETURN VALUE TO RETVAL'    
  CLC             
  ADC #$01     ;A+1,THEN RETURN      
  RTS             
OPNFLB LDX #$16     ;OPEN DISK FILE      
  JMP CDOSRT            
OPNFL LDA #$00             
  STA FCBBD     ;CLEAR SOME PLACE OF FCB   
  JSR FCBTOD     ;FCBP TO RDE     
  JMP OPNFLB     ;TO OPEN FILE     
CLSFIL LDX #$17     ;CLOSE FILE       
  JMP CDOSRT     ;       
SERFST LDX #$1C     ;SEARCH FOR FIRST      
  JMP CDOSRT            
SERNXT LDX #$1D     ;SEARH FOR THE NEXT     
  JMP CDOSR1            
SERFIL JSR FCBTOD     ;FCBP TO RDE      
  JMP SERFST            
FCBTOD LDA FCBP     ;FOR FCB TO RDE     
  STA RDE            
  LDA FCBP+1            
  STA RDE+1            
  RTS             
DELFIL LDX #$15     ;DELETE FILE       
;THE FOLLOWING ROUTINE CALLING CDOSB           
;RETURN ZERO IF SUCCESS            
;-------------------------------------               
  LDY #$21            
CDOSB LDA RDE             
  LDY RDE+1            
  JSR BDOS            
  CLC             
  RTS       ;RETURN VALUE<>0 IF FALSE   
RDSEQB LDX #$18     ;READ SEQUENTIAL       
  JMP CDOSB            
RDSEQ JSR FCBTOD     ;FCB TO RDE      
  JMP RDSEQB     ;TO READ SEQUENTIAL     
WRSEQ LDX #$19     ;WRITE SEQUENTIAL       
  JMP CDOSB            
MAKFIL LDX #$14     ;MAKE FILE       
  JMP CDOSRT     ;RETURN VALUE TO RETVAL'    
RENFIL LDA RDE             
  LDY RDE+1            
  LDX #$1E     ;RENAME FILE      
  JMP BDOS            
GETCOD LDA #$FF             
  STA RDE      ;$FF TO E    
SETCOD LDX  #$11     ;SET/GET ESER CODE     
  JMP BDOS     ;RETURN USER CODE IF GET'   
;PRINT PAGE              
;------------               
PRNPG1 JSR SPACE             
  JSR SPACE            
  LDY #$21     ;PAGE POSITION      
  LDA (RHL),Y     ;GET PAGE NUMB.     
  STA FCBB+$25    ;SAVE        
  INY             
  LDA (RHL),Y     ;GET PAGE MSB     
  STA FCBB+$26    ;SAVE        
  CLC             
  ROR FCBB+$26            
  ROR FCBB+$25            
PRNPG2 LDY #06      ;IF PAGE 000-999     
NXTDIG LDX #00      ;INIT DIGIT COUNT     
SUBEM LDA FCBB+$25    ;FETCH LSBY        
  SEC             
  SBC SUBTBL,Y    ;-LSBT OF TAB      
  STA FCBB+$25    ;RETURN TO MEMORY      
  LDA FCBB+$26    ;FETCH MSBY       
  INY             
  SBC SUBTBL,Y    ;-MSBY OF TAB      
  BCC ADBACK     ;IF RESULT IS -'    
  STA FCBB+$26    ;NO        
  INX             
  DEY       ;PTR LSBY IN TABLE   
  JMP SUBEM     ;LOOP       
ADBACK DEY       ;PTR LSBY IN TABLE    
  LDA FCBB+$25    ;FETCH LSBY       
  ADC SUBTBL,Y    ;+LSBY OF TAB      
  STA FCBB+$25            
  TXA       ;DIGIT COUNT TO A   
  ORA #$30     ;CONVERT TO ASCII     
  STY RNW      ;SAVE      
  JSR CHROUT     ;OUT DIGIT      
  LDY RNW      ;RESTORE Y     
  INY             
               
  INY       ;PTR TO NEXT TABLE   
               
  CPY #$0A            
               
  BCC NXTDIG     ;LOOP       
  LDA FCBB+$25            
  ORA DSKNUM            
  ORA #$30     ;CONVERT TO ASCII     
  JMP CHROUT     ;PRINT REMAINDER      
;CHANGE LOWER CASE TO UPPER CASE          
;----------------------------------------               
CUPCAS CMP #$61     ;CHAR>=LOWER CASE A ?     
  BCS LOPU1     ;NO,       
  RTS       ;YES,RETURN      
LOPU1 CMP #$7C     ;CHAR<LOWER CASE Z+1?      
  BCC LOPU2     ;NO,GO TO LOPU2     
  RTS       ;YES,RETURN      
LOPU2 AND #$5F     ;LOWER CASE TO UPPER CASE    
  RTS             
;COLD START,($01FF)=0:ROUTINE SHOW OP VERSION           
;WARM START,($01FF)<>0:ROUTINE HANDLE IN BUFF           
;----------------------------------------               
INBUFL LDA $01FF     ;'COLD START'?       
  CMP #$FF            
  BNE MJN      ;NO,      
  JSR CRLF            
  LDA MSGAD1            
  STA RHL            
  LDA MSGAD1+1    ;P        
  STA RHL+1     ;RHL POINTES CP/M VERSION--'    
  JSR STRIOB     ;PRINT MESSAGE STRING     
  JSR ENDINB     ;YES TO FILL 0 TO $01FF  
MJN  JMP START            
INBUFA LDA #$80     ;BUFF SIZE       
  STA IBUBCC     ;SAVE BUFF SIZE     
  LDA #<IBUBCC     ;BUFF ADDRESS 
  ;LDA #$80     
  LDY #IBUBCC/256            
  LDX #$06     ;INPUT BUFF LINE     
  JSR BDOS            
  LDA #<IBUBC         
  STA RHL            
  LDA #IBUBC/256            
  STA RHL+1     ;RHL POINTES INPUT BUFFER    
  LDX IBUBC     ;X AS COUNTER FOR NUMB OF CHAR 
  LDY #$00            
LOPIB1 INC RHL             
  TXA             
  BEQ BUFEND     ;NUMB.OF CHAR=0,BRANCH      
  LDA (RHL),Y     ;NO,GET A CHAR     
  JSR CUPCAS     ;LOWER CASE TO UPPER CASE   
  STA (RHL),Y     ;SAVE UPPER CHAR     
  DEX       ;COUNTER-1=0 ?     
  JMP LOPIB1     ;CONTINUE       
BUFEND STA (RHL),Y     ;0 TO (RHL)      
  LDA IBUFF            
  STA IBUFPA            
  LDA IBUFF+1            
  STA IBUFPA+1    ;IBUFPA POINTES HEAD OF BUFF    
  RTS             
CSTATD LDX #$09             
  JSR BDOS            
  PHA             
  PLA       ;FLAGE=O?      
  BNE LOPCS1     ;NO,BREANCH       
  RTS       ;YES,RETURN      
LOPCS1 LDX #$01     ;CONSOLE INPUT OPERATION      
  JSR BDOS            
  PHA             
  PLA       ;FLAGE Z=O?     
  RTS             
RETDKN LDX #$0C     ;RETURN CURRENT DISK      
  JMP BDOS            
STDMAI LDA #<DMAD           
  STA RDE            
  LDA #DMAD/256            
  STA RDE+1     ;RDE POINTES $0080BUF     
SETDMA LDX #$12     ;SET DMA OPERATION      
  LDA RDE            
  LDY RDE+1            
  JMP BDOS            
ENDINB LDA #$00             
  STA $01FF     ;0 TO STACK     
  LDA DSKNUM            
  JSR SELDSK     ;SELECT CURRENT DISK     
  RTS             
CMDEND JSR CRLF      ;OUTPUT CR''LF'      
  LDA  IBUFPB     ;IN BUFF TO RWK REF'3120'  
  STA  RWK           
  LDA IBUFPB+1    ;        
  STA RWK+1     ;RWK POINTES IN BUFF    
  LDY #$00            
LOPCN1 LDA (RWK),Y     ;GET A CHAR      
  CMP #$20     ;CHAR=' ?      
  BEQ ERENDC     ;YES       
  PHA             
  PLA       ;CHAR='0'      
  BEQ ERENDC     ;Y,       
  JSR CHROUT     ;OUTPUT CHAR      
  INC RWK            
  JMP LOPCN1     ;CONTINUE       
ERENDC LDA #$3F             
  JSR CHROUT     ;OUTPUT ?'      
  JSR CRLF     ;OUTPUT CR' LF'     
  JSR ENDINB     ;TO END COMMAND     
  JMP START            
;CHECK SPECIAL CHARACTER             
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
CHARCK JSR RDRDE     ;READ (RED)       
  CMP #$00            
  BEQ CHEND     ;RETURN IF CHAR='NUL'     
  CMP #$20     ;NO,CHECK CHAR=' ?     
  BEQ CHEND     ;YES,RETURN       
  BCC CMDEND     ;GO ERRORÑHANDLE' IF CHAR<' '   
  CMP #$3D     ;CHAR='='?       
  BEQ CHEND     ;YES,RETURN Z=0      
  CMP #$5F     ;CHAR='<Ñ'?       
  BEQ CHEND            
  CMP #$2E     ;CHAR='.'?       
  BEQ CHEND            
  CMP #$3A     ;CHAR=':'?       
  BEQ CHEND            
  CMP #$3B     ;CHAR=';'?       
  BEQ CHEND            
  CMP #$3C     ;CHAR='<'?       
  BEQ CHEND            
  CMP #$3E     ;CHAR='>'?       
  BEQ CHEND            
CHEND RTS              
RDRDE STY WRKPLD+1     ;SAVE Y       
  LDY #$00            
  LDA (RDE),Y     ;GET A CHAR     
  LDY WRKPLD+1    ;RESTORE        
  RTS             
;SKIP ' '             
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
SKPBLK JSR RDRDE     ;GET A CHAR.      
  CMP #$00            
  BEQ KPND     ;'BUFF-END'       
  CMP #$20     ;CHAR=' ?      
  BNE KPND     ;NO,RETURN       
  INC RDE      ;GET NEXT CHAR    
  JMP SKPBLK     ;LOOP       
KPND RTS              
;********************************************               
;FILL FCB FROM FCB'POINTER'+(A)            
;********************************************               
FIFCBM CLC              
  ADC RHL      ;(A)+(L)      
  STA RHL      ;TO (L)     
  BCC FIEND     ;RETURN IF FLAG C=0    
  INC RHL+1     ;NO,(H)+1       
FIEND RTS              
;FILL FCB FROM BEGINNING OF FCB          
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
FIFCBB LDA #$00             
FIFCB PHA              
  LDA FCBP            
  STA RHL            
  LDA FCBP+1            
  STA RHL+1     ;RHL POINTES FCB     
  PLA             
  JSR FIFCBM     ;(RHL)+(A) TO RHL     
  LDA RHL            
  STA RWK            
  LDA RHL+1            
  STA RWK+1     ;SAVE INITIAL VALUE OF RHL   
  LDA #$00            
  STA WRKPLA     ;CLEAR       
  STA WRKPLD     ;'WRKPLD'AS COUNTER FOR RDE    
  LDA IBUFPA            
  STA RDE            
  LDA IBUFPA+1            
  STA RDE+1     ;RDE POINTES INPUT BUFF    
  JSR SKPBLK     ;TO SKIP ' '    
  LDA RDE            
  STA IBUFPB            
  LDA RDE+1            
  STA IBUFPB+1    ;SAVE NEW POINTER IN IBUFPB    
  LDY #$00            
  INC RDE      ;PRT 2 CHAR    
  JSR RDRDE     ;GET 2'S CHAR     
  CMP #$3A     ;':'?       
  BEQ FIDKNN     ;YES,FILL DSKNUMB      
  LDA #$00            
  STA (RWK),Y     ;FILL PCB      
  LDA DSKNUM     ;CURRENT DISK      
  STA WRKPLA     ;SAVE REQ.DSKNUM      
  DEC RDE      ;RET 1'S CHAR IN BUFF  
  JMP FINAME            
FIDKNN DEC RDE      ;PTR 1'S CHAR IN BUFF   
  JSR RDRDE            
  SEC             
  SBC #$40            
  STA RWQ            
  STA WRKPLA     ;SAVE REG.DSKNUM      
  DEC WRKPLA            
MEDJN STA (RWK),Y     ;FILL D'TO PCB      
  INC RDE            
  INC RDE      ;PTR 3'CHAR IN BUFF   
;               
;FILL NAME' IN FCB            
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
FINAME LDX #$08     ;X AS COUNTER FOR 8 CHAR   
  LDA #$20            
  STA RNW      ;INIT ' '    
LOPFI1 JSR CHARCK     ;CHECK SPECIALCHAR       
  BEQ FIBLK1     ;TO FILL ' IF RET Z=0  
  INY             
  CMP #$2A     ;CHAR='*'?       
  BNE FICHAR     ;NO,TO FILL CHAR     
  LDA #$3F     ;YES,'?'TO A      
  STA (RWK),Y            
  STA RNW            
  JMP FINEXT            
FICHAR STA (RWK),Y     ;A CHAR TO FCB     
  LDA #$20            
  STA RNW            
FINEXT INC RDE      ;POINTES NEXT CHAR     
  DEX       ;COUNT X-1=0?     
  BNE LOPFI1     ;NO,LOOP       
               
;TO FIND THE END OF NAME          
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
FINDSG JSR CHARCK     ;TO CHECK SPECIAL CHAR     
  BEQ FITYP     ;TO FILL TYPE IF RET Z=0  
  INC RDE            
  JMP FINDSG     ;LOOP       
;               
;TO FILL ' ' IN FCB          
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
FIBLK1 PHA              
FIBLK INY              
  LDA RNW      ;' ' OR ? TO A 
  STA (RWK),Y     ;' ' TO FCB    
  DEX       ;COUNTER X-1=0?     
  BNE FIBLK     ;LOOP       
  PLA             
;TO FILL TYPE IN FCB           
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
FITYP LDX #$20             
  STX RNW            
  LDX #$03     ;X AS COUNTER FOR 3 CHAR  
  CMP #$2E     ;CHAR='>'?       
  BNE FIBLKT     ;NO,FILL ' IN FBC    
  INC RDE      ;RDE POINTES NEXT CHAR   
LOPTP JSR CHARCK     ;CHECK SPECIAL CHAR      
  BEQ FIBLKT     ;TO FILL ' IF RET Z=0  
  INY             
  CMP #$2A     ;CHAR='*'?       
  BNE FILLCH     ;NO,TO FILL CHAR     
  LDA #$3F     ;'?' TO A     
  STA (RWK),Y     ;'?'AS TYPE TO FCB    
  STA RNW            
  INC RDE      ;PTR NEXT CHAR    
  JMP NEXTP     ;TO FILL NEXT CHAR    
FILLCH STA (RWK),Y     ;CHAR TO FCB      
  LDA #$20            
  STA RNW            
  INC RDE      ;RDE POINTER NEXT CHAR   
NEXTP DEX       ;COUNTER X-1=0?      
  BNE LOPTP     ;NO,LOOP       
;TO FIND THE END OF COMMAND          
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
;               
;               
;               
;               
;               
;               
;               
;               
;               
BLNKJ1 JMP FIND5             
FNDEDG JSR CHARCK     ;TO CHECK SPECIAL CHAR.     
  BNE FIND5     ;IF RETURN Z=0     
  INC RDE      ;POINTES NEXT     
  JMP FNDEDG     ;LOOP       
FIBLKT INY              
  LDA RNW      ;' ' OR ? TO A 
  STA (RWK),Y     ;' ' TO FCB    
  DEX       ;COUNTER X-1=0?     
  BNE FIBLKT     ;NO,LOOP       
FIND5 LDX #$03     ;X AS COUNTER FOR 3'NUL'    
LOPFEN INY              
  LDA #$00     ;'NUL' TO A     
  STA (RWK),Y     ;TO FCB      
  DEX       ;COUNTER X-1=0?     
  BNE LOPFEN     ;NO,LOOP       
  LDA RDE            
  STA IBUFPA            
  LDA RDE+1            
  STA IBUFPA+1    ;SAVE INPUT BUFFER      
CKQUEN LDY #$00             
  STY RBC            
  LDX #$0B      ;X AS COUNTER FOR 11CHAR  
;COMPUTE ?'NUMBER IN FCB            
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
CHKQUE INY       ;SCAN FCB      
  LDA (RWK),Y     ;GET A CHAR FROM FCB   
  CMP #$3F     ;CHAR='?'?       
  BNE NEXCH     ;NO,GO TO NEXT CHER    
  INC RBC      ;C AS COUNTER FOR ?'NUMBER  
NEXCH DEX       ;COUNTER X-1=0?      
  BNE CHKQUE      ;NO,LOOP      
  LDA RBC            
  RTS             
;COMPARE THE COMMAND IN FCB WITH NAME TABLE        
;RETURN A=0 TO 6 WHICH POINTES COMMAND POSITION        
 ;*******************************************              
CMDCMP LDA TABADD             
  STA RWK            
  LDA TABADD+1            
  STA RWK+1     ;RWK POINTES COMMAND TABLE    
  LDY #$00            
  LDX #$00     ;X AS COUNTER FOR 6 COMMANDS  
LOPCM TXA              
  CMP #$06     ;COUNTER X>=6?      
  BCS CMPEND     ;YES,JUMP       
  LDA FCBPB            
  STA RDE            
  LDA FCBPB+1            
  STA RDE+1     ;RDE PTR COMMAND NAME    
  LDA #$04            
  STA RHL      ;HL AS COUNTER FOR COMPARE 4 C
CMPBGN JSR RDRDE     ;GET A CHAR FROM FCB    
  CMP (RWK),Y     ;EQUAL?       
  BNE CHGNX1     ;NO,TO CHANGE NEXT COMMAND    
  INC RDE      ;YES      
  INY             
  DEC RHL      ;COUNTER-1=0?      
  BNE CMPBGN     ;NO,CONTINUE       
  JSR RDRDE     ;YES,4 CHAR EQUAL     
  CMP #$20     ;' ' ?     
  BNE CHGNX2     ;NO.COMPARE AGAIN      
 ; LDA RDE            
 ; STA IBUFPA            
 ; LDA RDE+1            
 ; STA IBUFPA+1    ;PTR END OF COMMAND NAME??    
  TXA       ;YES,GET POSITION OF TABLE   
CMPEND RTS              
CHGNX1 INY              
  DEC RHL      ;#4COUNTER -1=0?     
  BNE CHGNX1     ;NO,LOOP       
CHGNX2 INX              
  JMP LOPCM     ;CONTINUE       
;SEPARATE USER CODE WITH DISK NUMB.          
;SET USER CODE,SELECT CURRENT DISK           
;*******************************************               
MAIN PHA              
  JSR RSTDSK     ;RESET DISK SYSTEM     
  PLA             
  STA DSKNUM     ;CURRENT DISK TO DSKNUM'    
  JSR SELDSK     ;TO SELECT CURRENT DISK    
  JMP INBUFL     ;VERSION SHOW?      
;*******************************************               
;START AFTER ENDING EACH CONSOLE COMMAND          
;*******************************************               
START LDX #$22             
  JSR BDOS            
  LDX #$FE            
  TXS       ;$FE TO SP    
  LDA DSKNUM            
  JSR SELDSK            
  JSR CRLF     ;OUTPUT CR' LF'     
  JSR RETDKN     ;RETURN CURRENT DISK     
  CLC             
  ADC #$41     ;CHANGE DISK NUMB.TO CHA    
  JSR CHROUT     ;OUTPUT A' OR B'- -   
  LDA #$3E     ;'>' TO A     
  JSR CHROUT     ;OUTPUT >'      
  JSR INBUFA     ;RECEIVE MESSAGE FROM CONSOLE    
  LDA IBUBC+$2    ;2'S CHAR IN BUFF     
  CMP #$3A     ;':'?       
  BEQ BPSDK            
ENTRYA LDA #<DMAD             
  STA RDE            
  LDA #DMAD/256            
  STA RDE+1     ;RDE POINTES DMA ADDRESS    
  JSR SETDMA     ;SET DMA      
  JSR FIFCBB     ;FILL COMMAND IN FCB,RET ?'CO   
  BNE CMDND1     ;IF RET'?'COUNT<>0,ERR COMMAND     
  JSR CMDCMP     ;TO COMPARE COMMAND     
;BASED ON TAB POSITION RETURNED BY CMDCMP'         
;,PROGRAM JUMP TO DIFFERENCE ENTRY           
;*******************************************               
  STA RWK      ;SAVE RETURN VALUE    
  LDA TBLAD2     ;ENTRY ADDR.TABLE TO A    
  STA RHL            
  LDA TBLAD2+1    ;        
               
               
               
               
  STA RHL+1     ;RHL POINTES ENTRY ADDR.TABLE    
  LDA RWK            
  CLC             
  ADC RWK      ;(RETURN VALUE)*2     
  ADC RHL      ;      
  STA RHL            
  LDA #$00     ;REMAIN FLAGE C     
  ADC RHL+1            
  STA RHL+1     ;TABL.HEAD+(RET.VAL.)*2       
  LDY #$00            
  LDA (RHL),Y            
  STA RWK            
  INY             
  LDA (RHL),Y            
  STA RWK+1            
  JMP (RWK)     ;TO DIFFERENCE ENTRY     
CMDND1 JMP CMDEND     ;END ERR.COMMAND       
BPSDK LDA IBUBC+$3    ;3'S CHAR        
  CMP #$00     ;'00'?       
  BNE ENTRYA     ;NOT A: OR B:COMMAND    
  JMP PSDK     ;A: OR B: COMMAND    
;SOME LOCAL SUBROUTINES             
;*************************               
;OUTPUT ERROR MESSAGE             
;~~~~~~~~~~~~~~~~~~~~               
PRTER1 LDA RDERRA     ;MESSAGE ADDR.TO A      
  STA RBC            
  LDA RDERRA+1            
  STA RBC+1     ;RBC POINTES MESSAGE'     
  JMP STRIOA     ;OUTPUT DEAD ERROR'     
PRTER2 LDA NOFERA     ;MESSAGE ADDR. TO A     
  STA RBC            
  LDA NOFERA+1            
  STA RBC+1     ;RBC POINTES MESSAGE'     
  JMP STRIOA     ;OUTPUT NO FILE'     
;'DIGIT' HANDLE FOR PAGE & USER CODE         
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
DIGHD JSR FIFCBB     ;FILL DIGIT' IN FCB     
;  LDA WRKPLA            
;  BNE DIGEN1     ;ERR.END       
  LDA #$00            
  STA RWQ      ;RWQ FOR SAVING HIGH BITS  
  LDA FCBPB     ;       
  STA RHL            
  LDA FCBPB+1            
  STA RHL+1     ;RHL POINTES FCB     
  LDY #$00            
  LDX #$0B     ;X AS COUNTER FOR 11 CHAR.  
LOPDIG LDA (RHL),Y     ;GET A CHAR      
  CMP #$20     ;CHAR=' ?      
  BEQ SKPEN1     ;YES,JUMP TO END     
  INY       ;NO,      
  SEC             
  SBC #$30     ;CHAR-'0'BIAS       
  CMP #$0A     ;CHAR<=9?       
  BCS DIGEN1     ;NO, END ERR.COMMAND     
  STA RWK      ;SAV ELOWER BITS    
  LDA RWQ      ;HIGH BITS TO A   
  AND #$E0            
  BNE DIGEN1     ;TO END ERR.COMMAND IF A<>0   
  LDA RWQ            
  CLC             
  ROR             
  ROR             
  ROR             
  ROR             
  ROR             
  ROR       ;(A)LEFT SHIFT 4    
  ADC RWQ      ;OVERFLOW?      
  BCS DIGEN1     ;YES,ERR.       
  ADC RWQ      ;OVERFLOW?      
  BCS DIGEN1     ;YES,ERR.       
  ADC RWK      ;ADD LOW BITS    
  BCS DIGEN1     ;ERR.IF OVERFLOW      
  STA RWQ      ;SAVE NEW HIGH BITS   
  DEX       ;COUNTER X-1=0?     
  BNE LOPDIG     ;NO,LOOP       
  RTS             
DIGEN1 JMP CMDEND     ;TO END ERR.COMMAND      
SKPEN1 LDA (RHL),Y     ;GET A CHAR      
  CMP #$20     ;CHAR=' ?      
  BNE DIGEN1     ;NO,ERR.       
  INY             
  DEX       ;COUNTER X-1=0?     
  BNE SKPEN1     ;NO,LOOP       
  LDA RWQ      ;'DIGIT' TO A ,RETURN   
  RTS             
;MOVE ROUTINE              
;~~~~~~~~~~~~~~~~~~~~~~               
MV3CHR LDX #$03     ;X AS COUNTER FOR MOVING 3 BYT  
BLKMOV LDY #$00             
BLKMO2 LDA (RHL),Y     ;GET CHAR       
  STA (RDE),Y     ;SAVE CHAR      
  INY             
  DEX       ;COUNTER X-1=0?     
  BNE BLKMO2     ;LOOP       
  RTS             
;COMPUTE DIR.ADDR.&GET ACHAR.             
;~~~~~~~~~~~~~~~~~~~~~~~~~~~               
DMACUN LDY #<DMAD            
  STY RHL            
  LDY #DMAD/256            
  STY RHL+1     ;RHL POINTES DMA ADDR.    
  CLC             
  ADC RBC      ;(C):DIR,RELATIV.POSITION      
  JSR FIFCBM     ;RHL+A TO RHL     
  LDY #$00            
  LDA (RHL),Y     ;GET A CHAR     
  RTS             
;*******************************************               
;A:,B:,C:----,COMMAND               
;*******************************************               
PSDK LDA IBUBC+$1    ;DISK CHAR        
  SEC             
  SBC #$41     ;DISK NUMBER      
  PHA             
  JSR SELDSK     ;CHANR-DSK       
  PLA             
  STA DSKNUM            
  JMP START            
;*************************************               
;DIR COMMAND HANDLE ROUTINE            
;*************************************               
PDIR JSR FIFCBB     ;FILL FILE NAME IN FCB    
  LDA WRKPLA            
  JSR SELDSK            
  LDA FCBPB            
  STA RHL            
  LDA FCBPB+1            
  STA RHL+1     ;RHL POINTES FCB     
  LDY #$00            
  STY FCBB+$0C    ;CLARE SOME PLACE      
  LDA (RHL),Y     ;GET FIRST CHAR FOR D-NAME   
  CMP #$20     ;CHAR=' ?      
  BNE BRNCHB     ;NO,BEGIN TO SEARCH FILE    
  LDX #$0B     ;YES,X AS COUNTER FOR 11 CHAR  
PATCHQ LDA #$3F     ;'?' TO A      
  STA (RHL),Y     ;'?' TO FCB     
  INY             
  DEX       ;COUNTER X-1=0?     
  BNE PATCHQ     ;NO,LOOP       
BRNCHB LDA #$00             
               
  STA RWK      ;CLEAR COUNTER'RWK'     
  JSR CRLF     ;OUT CR' LF'     
  LDA WRKPLA     ;REQ.DISK       
  CLC             
  ADC #$41     ;TO DISK NUMB.     
  JSR CHROB     ;OUT DISK NAME     
  LDA #$3A     ;: TO A     
  JSR CHROB     ;OUT :'      
  JSR SERFIL     ;SEARCH FOR THE FIRST    
  BNE LOPDIR     ;SEARCH SUCCESS,JUMP TO     
  JSR PRTER2     ;SEARCH FALSE,PRINT'NO FILE'     
  JMP DIREND     ;TO END COMMAND     
LOPDIR LDA RETVAL     ;RET VALUSE TO A     
  ROR             
  ROR             
  ROR             
  ROR             
  AND #$60            
  STA RBC      ;(RET VALUES*32) TO RBC   
  STA RWQ            
  LDA #$0A     ;CHECK PROTECT      
  JSR DMACUN     ;COUNT DIR ADDRESS     
  BMI NXTDR2     ;       
  LDA RWK            
  INC RWK      ;COUNTER+1      
  AND #$03            
  STA RWQ+1     ;SAVE       
  BNE WARMR            
  JSR CRLF            
  INC RWK            
  JMP COMMON            
WARMR JSR SPACE     ;OUTPUT ' '      
  JSR SPACE     ;OUT ' '     
  JSR SPACE     ;OUT ' '     
COMMON JSR SPACE     ;OUTPUT ' '      
  LDA RWQ            
  STA RBC      ;(C):RET.VAL.*32      
  LDX #$01     ;X AS COUNTER,INITIAL VAL 1   
  STX RNW      ;SAVE X'REG.     
ONEDIR LDA RNW      ;CHAR COUNTER TO A    
  JSR DMACUN     ;GET CHAR      
  AND #$7F            
  JSR CHROB     ;OUT CHAR      
  LDX RNW            
  CPX #$08     ;END FILE NAME ?    
               
               
               
               
               
  BNE MEDIR2            
  JSR SPACE     ;INSERT ' '     
  LDX RNW            
MEDIR2 CPX #$0C     ;END TYPE?       
  BEQ NXTDR2            
  INC RNW            
  BNE ONEDIR            
NXTDR2 LDA #$00             
  JSR DMACUN     ;RHL PTR FCB     
  LDA RHL            
  STA RDE            
  LDA RHL+1            
  STA RDE+1     ;RDE PTR FCB     
  LDA FCBB            
  LDY #$00            
  STA (RHL),Y     ;WRITE DSK TO FCB'    
  LDX #$20     ;COUNT PAGE NUMB.     
  JSR CDOSRT            
  JSR PRNPG1     ;PRINT PAGE      
  JSR CSTATD     ;GET CONSOLE STATUE     
  BNE DIREND     ;IF STAT.<>0,JUMP      
  JSR SERNXT     ;SEARCH FOR NEXT     
  BEQ DIREND            
  JMP LOPDIR            
DIREND LDA RWK      ;COUNTER TO A     
  JMP PEND            
;*************************************               
;* ERA COMMAND HANDLE ROUTINE   *        
;*************************************               
PERA JSR FIFCBB     ;FILL FILE NAME IN FCB    
  CMP #$0B     ;RETURN IF RET ?'COUNT.=11    
  BNE DELEFI     ;NO,GO DELETE FILE     
  LDA MSGAD3     ;YES,ERR.       
  STA RBC            
  LDA MSGAD3+1    ;        
  STA RBC+1     ;RBC POINTES MESSAGE'ALL(Y/N)?     
  JSR STRIOA     ;OUTPUT ALL (Y/N)?'     
  JSR INBUFA     ;WAIT FOR ANSWER     
  LDA IBUBC     ;INPUT BUFF COUNTER TO A   
  CMP #$01     ;BUFF COUNTER=1?      
  BNE ERAEN1     ;NO,GO TO END COMMAND    
  LDA IBUFB     ;YES,GET CHAR      
  CMP #$59     ;CHAR='Y'?       
  BNE ERAEN1     ;NO,ERR. JUMP      
  INC IBUFPA     ;PTR BUFF IN BUFF    
DELEFI JSR FCBTOD     ;FCB PTR RDE      
  JSR DELFIL     ;DELECT FILE ,A=0~3IF SUCCESS    
  CMP #$FF     ;RET VAL.=$FF IF FALSE    
  BEQ ERAEN2     ;FALSE,JUMP       
  JMP PEND     ;SUCCESS,END       
ERAEN1 JMP START             
ERAEN2 JSR PRTER2     ;OUT NO FILE'      
  JMP PEND            
;***********************************************               
;* TYPE COMMAND HANDLE ROUTINE     *      
;***********************************************               
PTYPE JSR FIFCBB     ;FILL FILE NAME IN FCB    
  BNE TYPEN1     ;IF RET ?'COUNT<>0,GO TO END   
  LDA WRKPLA            
  JSR SELDSK            
  JSR OPNFL     ;OPEN FILE      
  BEQ ERENDT     ;OPEN FALSE,JUMP      
  JSR CRLF     ;SUCCESS,OUTPUT CR''LF'      
WRTTP LDY #<DMAD             
  STY RHL            
  LDY #DMAD/256            
  STY RHL+1     ;RHL POINTES DMAD     
TPBEGN JSR RDSEQ     ;READ DISK       
  BNE TEND     ;IF READ FALSE     
  LDY #$00            
MEDTY LDA (RHL),Y     ;GET CHAR       
  CMP #$1A     ;CHAR=CTL-Z?,EOF?       
  BEQ BLNKT     ;YES       
  STY RNW            
  JSR CHROUT     ;NO,OUTPUT A CHAR     
  JSR CSTATD     ;GET CONSOLE STATUES     
  BNE BLNKT     ;IF STATUES<>0,GO END     
  LDY RNW            
  INY             
  CPY #$80     ;TYPE 128 CHAR     
  BNE MEDTY     ;NO,LOOP       
  JMP TPBEGN            
BLNKT JMP PEND             
TEND CMP #$01     ;'1'SHOWS EOF       
  BEQ BLNKT     ;YES       
  JSR PRTER1     ;NO,OUTPUT'READ ERROR'      
ERENDT NOP              
TYPEN1 JMP CMDEND     ;TO END ERR. COMMAND     
BLNKS JMP SAEND             
;******************************************               
;* SAVE COMMAND HANDLE ROUTINE    *       
;******************************************               
PSAVE JSR DIGHD      ;FILL PAGE NUMB. RET NUMBER   
  PHA             
  JSR FIFCBB     ;FILL FILE NAME IN FCB,RET'?#   
  BNE TYPEN1     ;'?'COUNT.<>0,ERR. GO ERR END    
  LDA WRKPLA            
  JSR SELDSK            
  JSR FCBTOD     ;FCB POINTER TO RDE    
  JSR DELFIL     ;DELECT FILE IF IT EXISTED   
  JSR FCBTOD     ;       
  JSR MAKFIL     ;MAKE FILE,RET'0'IF FALSE     
  BEQ BLNKS     ;FALSE,JUMP TO END     
  LDA #$00            
  STA RWK+1            
  STA FCBBD     ;CLEAR SOME PLACE     
  CLC             
  PLA             
  STA RWK            
  ADC RWK      ;NUMB.*2      
  BCC ENTR1     ;LOW BITS NO'C' JUMP    
  INC RWK+1     ;ADD'C'       
ENTR1 STA RWK      ;PAGE N*2 TO RWK    
  LDA #<STRTD            
  STA RDE            
  LDA #STRTD/256            
  STA RDE+1            
SAVBGN LDA RWK             
  ORA RWK+1            
  BEQ SFINISH     ;CHECK PAGE NUMB.=0?     
  LDA RWK      ;YES,END      
  SEC             
  SBC #$01            
  BCS ENTR2            
  DEC RWK+1            
ENTR2 STA RWK             
  LDA #$80     ;128 BYTES      
  CLC             
  ADC RDE      ;+128      
  STA RHL            
  LDA RDE+1            
  ADC #$00            
  STA RHL+1     ;RHL POINTES NEXT RDE A@@R.   
  JSR SETDMA     ;USINC RDE,SET DMA     
  JSR FCBTOD     ;R@E POINTES FCB     
  JSR WRSEQ     ;WRITE SEQUANTIAL,RET 0 IF SUCCE   
  BNE SAEND     ;WRIPA FALSE(ERRRRRR* AJD     
  LDA RHL            
  STA RDE            
  LDA RHL+1            
  STA RDE+1     ;RDE POINTES NEW DIA ADDR.   
  JMP SAVBGN     ;LOOP       
SFINISH JSR FCBTOD     ;RDE POINTES FCB      
  JSR CLSFIL     ;CLOSE BILE      
  CMP #$00     ;RETURN=0.CLOSE FALSE      
  BNE SAEND2     ;SUCCASS,JUMPTO--       
SAEND JSR CRLF     ;OUTPUT CR' LF'      
  LDA MSGAD5            
  STA RHL            
  LDA MSGAD5+1            
  STA RHL+1     ;RHH POINPES NK SPACE'    
  JSR STRIOB     ;OUT NO SPACE'     
SAEND2 JSR STDMAI     ;INITIAL DMA ADDR.      
  JMP PEND            
ERENDZ JMP CMDEND     ;END ERR.       
;************************************               
;* RENAME COMMAND HANDLE ROUTINE           
;************************************               
PREN JSR FIFCBB     ;FILL FILE NAME IN FCB,RET    
  BNE ERENDZ     ;IF RET'?'COUNTER<>0,ERR.      
  LDA WRKPLA     ;REQUIRED DISK NO.TO A    
  STA WRKPLC     ;SAVE       
  LDA FCBP     ;NO REPEAT NAME,     
  STA RHL            
  LDA FCBP+1            
  STA RHL+1     ;RHL POINTES NEW FILE NAME FCB  
  LDA FCBPC            
  STA RDE            
  LDA FCBPC+1            
  STA RDE+1     ;RDE POINTES TEMP.SAVE ARE    
  LDX #$10     ;X AS COUNTER FOR MOVING16 CHA  
  JSR BLKMOV     ;MOVE NEW NAME TO TEMP.AREA   
  LDA IBUFPA            
  STA RDE            
  LDA IBUFPA+1    ;        
  STA RDE+1     ;RDE POINTES INPUT BUFFER    
  JSR SKPBLK     ;TO SKIP ' '    
  CMP #$3D     ;CHAR='='?       
  BEQ FIOLDN     ;YES,JUMP TO FILL OLD NAME   
  CMP #$5F      ;CHAR='<-`?      
  BNE ERENDN      ;NO,ERR. JUMP     
FIOLDN CLC              
  LDA RDE            
  ADC #$01            
  STA IBUFPA            
  LDA #$00            
  ADC RDE+1            
  STA IBUFPA+1    ;MODIFY IN-BUFF PTR      
  JSR FIFCBB     ;FILL OLD FILE NAME    
  BNE ERENDN     ;RET ?'COUNT.<>0,ERR.      
  LDA FCBBC     ;OLD DSK IN FCB    
  BEQ USNEWN            
  LDA FCBB            
  BEQ USNEWN     ;(A)=0,G0,USE NEW FILE DSK    
  LDA WRKPLA            
  CMP WRKPLC     ;COMPARE NEW DSK WITH OLD D  
  BNE ERENDJ     ;ERR.       
USNEWN LDA FCBBC             
  ORA FCBB            
  STA FCBB            
  STA FCBBC            
  LDA FCBPC            
  STA RDE            
  LDA FCBPC+1            
  STA RDE+1     ;RDE PTRNEWFILE      
  JSR SERFIL+3    ;SEACH NEW FILE      
  BNE ERENDR            
  JSR SERFIL     ;SEARCH FOR OLD NAME FILE   
  BEQ PRTEND     ;SEARCH FALSE,'NO FIRE'     
  JSR FCBTOD     ;SUCCESS,RDE POINT.FCB      
  JSR RENFIL     ;RENAME FILE      
  JMP PEND     ;NORMALLY END      
PRTEND JSR PRTER2     ;OUTPUT NO FILE'      
  JMP PEND            
ERENDN JMP CMDEND     ;ERR.        
ERENDR JSR CRLF     ;OUTPUT CR' LF'      
  LDA MSGAD7            
  STA RHL            
  LDA MSGAD7+1    ;        
  STA RHL+1     ;RHL POINTES'FILE EXISTS`     
  JSR STRIOB     ;PRINT       
  JMP PEND            
ERENDJ JMP CMDEND     ;END ERR.       
;******************************************               
;* USER COMMAND HANDLE ROUTINE           
;******************************************               
PUSER JSR DIGHD     ;FILL DIGIT'IN FCB COUNT     
  CMP #$10     ;USER CODE>=16?      
  BCS ERENDJ     ;YES,ERR. TO END     
  LDX FCBBB            
  CPX #$20     ;1'S CHAR=' ?     
  BEQ ERENDJ      ;YES,ERR.      
  JSR SETCOD     ;SET USER CODE     
BLKTR JMP PEND             
;******************************************               
;* TRANSIENT PROGRAM COMMAND HANDLE ROUTINE          
;******************************************               
;PTRANS LDA FCBB ;GET DSK NUMB. IN FCB        
;               
PTRANS LDA WRKPLA             
;  STA DSKNUM            
;  DEC DSKNUM     ;TO CHANGE CURRENT DISK    
;  JSR WRTDKN     ;SAVE CURRENT DISK #0004    
  JSR SELDSK            
  LDA #<FCBB      ;FCB ADDRESS     
  STA RWK            
  LDA #FCBB/256            
  STA RWK+1      ;RWK PIR FCB    
  JSR CKQUEN      ;COUNT'?'      
  BNE ERENDJ      ;JUMP TO END ERR.COMMAND   
  LDA IBUFPA+1            
  PHA             
  LDA IBUFPA            
  PHA             
FICOM LDA FCBB+9      ;TYPE 1'SCHAR      
  CMP #$20            
  BNE ERENDJ            
  LDA FCBP            
  CLC             
  ADC #$09            
  STA RDE            
  LDA #$00            
  ADC FCBP+1            
  STA RDE+1     ;RDE POINTES (FCBP+8)     
  LDA MSGDD9            
  STA RHL            
  LDA MSGDD9+1            
  STA RHL+1     ;RHL POINTES COM'     
  JSR MV3CHR     ;FILL COM'IN FCB     
  JSR OPNFL     ;OPEN FILE      
  BEQ BLKJ6     ;OPEN FALSE,ERR.      
  LDA #<STRTD     ;OPEN SUCCESS,      
  STA RWK            
  LDA #STRTD/256            
  STA RWK+1     ;RWK POINTES INPUT ADDR,    
RDDSK LDA RWK             
  STA RDE            
  LDA RWK+1            
  STA RDE+1     ;RDE POINTES INPUT ADDRESS    
  JSR SETDMA     ;SET DMA      
  JSR FCBTOD     ;RDE POINTES FCB     
  JSR RDSEQB     ;READ SEOUENTIAL,RETO IF SUCCES    
  BNE RDEND     ;REAR FALSE,GO END     
  CLC             
  LDA RWK      ;GET INPUT ADDR.    
  ADC #$80     ;+128 BYTES      
  STA RWK            
  LDA #$00            
  ADC RWK+1            
  STA RWK+1     ;RWK SAVE NEW INPUT ADDR.   
  CMP #$B0     ;CHECK OVER LOAD?     
  BCS BLKJ7     ;OVER,ERR.       
  JMP RDDSK     ;NO,LOOP       
BLKJ6 JMP PRTERB             
BLKJ7 JMP PRTERP             
RDEND CMP #$01     ;CHECK EOF?       
  BNE BLKJ7     ;NO,ERR.       
  JSR FIFCBB     ;FILL FILENAME FOLLOWING COMMA.    
  INC WRKPLA            
  LDA WRKPLA     ;FIRST FILE DSK TO A   
  STA FCBB     ;FILL       
  STA RWQ      ;SAVE      
  LDA #$10     ;FOR FILLING SECOND FILE NAME   
  JSR FIFCB     ;SECOND FILE NAME TO FCB   
  LDA RWQ      ;FIRST FILE DISK TO A  
  STA FCBB+16     ;AS SECOND FILE DISK    
  LDA #$00            
  STA FCBB+32     ;CLEAR A BYTE     
  LDA #$10            
  STA RDE            
  LDA #$EF            
  STA RDE+1     ;RDE PTR $EF10 FOR 2'S FILE NAM 
  LDA FCBP            
  STA RHL            
  LDA FCBP+1            
  STA RHL+1     ;RHL POINTES FCB     
  LDX #$21     ;X AS COUNTER FOR 33CHAR   
  JSR BLKMOV     ;MOVE FROM FCB TO NEW SAVE AREA 
               
               
               
               
               
               
  PLA             
  STA RHL            
  PLA             
  STA RHL+1     ;RHL POINTES INPUT BUFFER    
  LDY #$00            
FNBLK LDA (RHL),Y     ;GET CHAR       
  BEQ MVEND            
  CMP #$20     ;CHAR=' /      
  BNE NEWLIN     ;Y,JMP       
  LDA #$01            
  JSR FIFCBM     ;RHL+1       
  JMP FNBLK     ;LOOP       
NEWLIN LDX #$00     ;INITIAL COUNTER X=0      
  LDA #<DMAD          
  STA RDE            
  LDA #DMAD/256            
  STA RDE+1            
  INC RDE      ;RDE PTR $E965 FOR SAVING OTHER 
  LDY #$00            
MVSTAR LDA (RHL),Y             
  STA (RDE),Y     ;MOVE A CHAR     
  BEQ MVEND     ;IF CHAR=0,ST0P MOVING     
  INX       ;COUNTER X+1     
  INY             
  JMP MVSTAR     ;LOOP       
MVEND TXA              
  LDY #$00            
  DEC RDE            
  STA (RDE),Y     ;$E965 SAVE INFO, COUNTER    
;FROM $E966 TO E966+(E965 COUNT) SAVE ALL PARAME.        
;FROM $EF10 TO EF30 SAVE SAVE TWO COMMAND INCL.DSK       
;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~               
;*************************************************               
  JSR CRLF     ;OUTPUT CR' LF'     
  JSR STDMAI     ;SET DMA=DMAD      
EXECUT JSR STRTD      ;GO TO EXECUTE PROGRAM    
  LDA DSKNUM     ;CURRENT DISK      
  JSR SELDSK     ;SELECT CURRENT DISK     
  JMP START            
PRTERB NOP              
  JMP CMDEND     ;ERR.END       
PRTERP JSR CRLF     ;OUTPUT CR' LF'      
  LDA MSGBA2            
  STA RHL            
  LDA MSGBA2+1    ;        
  STA RHL+1     ;RHL POINTES BAD LOAD'    
  JSR STRIOB     ;PRINT       
  JMP PEND            
PEND JSR FIFCBB     ;FILL REMAIN SOMETHING      
  LDA FCBBB     ;GET CHAR FROM FCB    
  SEC             
  SBC #$20     ;SUB ' VALUE     
  ORA WRKPLA            
  BNE PENER     ;(A)<>0,ERR,END       
  JMP START     ;END NORMALLY      
PENER JMP CMDEND     ;        
MSGVER .BYTE "O.U.6502 CP/M VERSION",$0D,$0A           
  .BYTE " DIR ERA TYPE SAVE REN B:",$00      
               
               
               
               
               
RDERR .BYTE "READ ERROR",$00            
NOFERR .BYTE "NO FILE",$00            
MSGADI .BYTE "ALL (Y/N)?",$00            
MSGAD4 .BYTE "NO SPACE",$00            
MSGAD6 .BYTE "FILE EXISTS",$00            
MSGDD8 .BYTE "COM"             
MSGBA1 .BYTE "BAD L0AD",$00            
  .END             
